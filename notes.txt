React Ecommerce Neil Cummings Working with Rider

github.com/tryCatchLearn/restore

https://www.udemy.com/course/learn-to-build-an-e-commerce-store-with-dotnet-react-redux/learn/lecture/28964744#overview

dotnet cli

Whats a web API : Http based services on top of .net

client http request and server sends http response
stateless
cacheable 
uniform interface

/Products     	GET      get all products
/Products/3		GET		 get product with id 3
/Products		POST     create new product
/Products/3		PUT		 update product with ID 3
/Products/3		DELETE	 delete product with ID 3 


dotnet new -l    // list all project types


create solution file and then and webapi


our solution is called ReStore

	dotnet new sln // creates solution

	dotnet new webapu -o API    // output folder


add project to solution
	dotnet sln add API



dotnet watch run  // means don't need to  restart - how to do this in Rider


EF

modelling
querying
change tracking
saving
concurrency
transactions
caching
conventions
configurations
migrations

add EF using nuget
<PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="5.0.11">
<PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" Version="5.0.11" />



see API.csproj (show this file by selecting 'File System' in project explorer)


So as to do migrations

https://www.nuget.org/packages/dotnet-ef
at command line
a global tool
dotnet tool install --global dotnet-ef --version 5.0.11


Added the connection string in appsettings.developement.json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",                   <<<<< change to Information so we get sql with ef
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Data source=store.db"
  }
}

Ran this in terminal within project API folder
R:\Code\Udemy\Neil\ReactEcommerce\ReStore\API> dotnet tool install --global dotnet-ef --version 5.0.11
says its already installed - Yah


update tools
PS R:\Code\Udemy\Neil\ReactEcommerce\ReStore\API> dotnet tool update --global dotnet-ef --version 5.0.11

list tools
PS R:\Code\Udemy\Neil\ReactEcommerce\ReStore\API> dotnet tool list -g

run
dotnet ef 
to see list of options

Usage: dotnet ef [options] [command]


Options:
  --version        Show version information
  -h|--help        Show help information
  -v|--verbose     Show verbose output.
  --no-color       Don't colorize output.
  --prefix-output  Prefix output with level.


Commands:
  database    Commands to manage the database.
  dbcontext   Commands to manage DbContext types.
  migrations  Commands to manage migrations.


create migration
dotnet ef migrations add InitialCreate -o Data/Migrations    <--- first off indicae where these are


how to apply latest code changes ef
	dotnet ef database update
	
	
 dotnet ef database drop	
 
 Source control Dotnet new -l list all dotnet templates there is  a .gitignore
 dotnet new gitignore
 
 
 material ui v5    import from "@mui/material" not "@material-ui/core"
 
 
 R:\Code\Udemy\Neil\ReactEcommerce\ReStore>npx create-react-app client --template typescript --use-npm
 
 the use npm ensures that even if theres another package manager is installed we use npm, also
 using typescript
 
 hook useEffect used to add a side effect during app lifecycle. 
 It takes 2 params a) callback and b) optional 2nd param
 
 Cors API on port 5001 client on 3000 seen as diff domains
 config the API so it accepts requests from the 3000 and populate the response with correct 
 origin info data as part of the header
 
 update the startup services and configure methods. The order in configuration important 
 need to add cors settings after routing
 
 Client should see response header access control allow origin http://localhost:3000
 
 
 use json2ts - go to swagger endpoint browser on json output and copy into that site to convert to typescript
 then populate Product.tsx file
 
 
 typescript type of [] is a never array
 
 
 project organisation - by feature
 
 Fragments - avoids top level div in component
 see Catalog 
 long way is
     import {Fragment} from "react";
            <Fragment> .... </Fragment>
 shorthand
    no import and write <> </>     
    
 Simplify avoid using props. we destructure
    from props: Props
    to {products, addProduct} : Props
    
    where Props defined as 
    interface Props {
        products: Product[];
        addProduct: () => void;
    }   
    
 Styling   
 old version doesn't play well with react in strict mode
 material ui    
    https://material-ui.com/     
    npm install @material-ui/core
 new version    
    mui.com     (https://mui.com/getting-started/installation/)   
    npm install @mui/material @emotion/react @emotion/styled
    
    add font
    add svg material icons
    
    customisation theme typography https://mui.com/customization/typography/
    
Reset browser styles Add to app.tsx <CssBaseline/>    
Added material UI card based on media one https://mui.com/components/cards/   
The sx prop in material ui shortcut for defining custom styles https://mui.com/system/the-sx-prop/
this is used to add normal css styles e.g. see ProductCard

material UI theme > theming  https://mui.com/customization/theming/
toggle button see app.tsx and header.tsx


React Router
------------
Without router simple option return page based on series of if statements
Same page but swaps the components
React Router - web version  npm install react-router-dom
install type definitions
npm install react-router-dom @types/react-router-dom
www.reactrouter.com/web/api
<BrowserRouter> in index

in app
        <Route exact path='/' component={HomePage}/>
        <Route exact path='/catalog' component={Catalog}/>
        <Route path='/catalog/:id' component={ProductDetails}/>
        <Route path='/about' component={AboutPage}/>
        <Route path='/contact' component={ContactPage}/>

http://localhost:3000                     <-- home page
http://localhost:3000/catalog             
http://localhost:3000/about

need 'exact' as the default way path matching happens is '/' matches home and everything else
so we get both homepage and any other components. With exact only '/' matches

header.tsx use react-router 
NavLink - applies an active class - we use this on header
Link - no active class - we use this ProductCard Button 

Passing parameters in the path (see Product Card) 
component={Link} to={`/catalog/${product.id}` 
<Button component={Link} to={`/catalog/${product.id}`} size="small">View</Button> 

links to ProductsDetails, access the param from there
hook - useParams
const {id} = useParams<{id: string}>();

our backend api /localhost:5000/api/products/2 
 

Axios - replace Fetch
---------------------

npm install axios (it comes with type definitions included)
Http client intercept request on way out and response on way back

Material UI 
see themes here https://mui.com/customization/default-theme/  (expand all)
sx styling hover 
'&:hover':{color:'secondary.main'} or better color
'&:hover':{color:'grey.500'},
see Header.tsx
select a class for active link 
'&.active':{color: 'text.secondary'}


Error Handling
--------------
Http Responses
200 range     OK
300           Redirection
400           Client error
500           Server Error  
both client and server side

buggyController used to test errors 
swagger
https://localhost:5001/swagger/index.html

replace stand developer exception page with our own
https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0
ordering of middleware is crucial - passed down the tree and back up again see diag at Middleware order

define own exception handling so as to standardise the reponse title, status, detail that show the exception

Client side centralise use of axios

we use the about page to test errors

In axios use error.response instead of error to get back more info (see ProductDetails)