React Ecommerce Neil Cummings Working with Rider

github.com/tryCatchLearn/restore

https://www.udemy.com/course/learn-to-build-an-e-commerce-store-with-dotnet-react-redux/learn/lecture/28964744#overview

API Server first build
======================

dotnet cli

Whats a web API : Http based services on top of .net

client http request and server sends http response
stateless
cacheable 
uniform interface

/Products     	GET      get all products
/Products/3		GET		 get product with id 3
/Products		POST     create new product
/Products/3		PUT		 update product with ID 3
/Products/3		DELETE	 delete product with ID 3 


dotnet new -l    // list all project types


create solution file and then and webapi


our solution is called ReStore

	dotnet new sln // creates solution

	dotnet new webapu -o API    // output folder


add project to solution
	dotnet sln add API



dotnet watch run  // means don't need to  restart - how to do this in Rider


EF
--

modelling
querying
change tracking
saving
concurrency
transactions
caching
conventions
configurations
migrations

add EF using nuget
<PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="5.0.11">
<PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" Version="5.0.11" />



see API.csproj (show this file by selecting 'File System' in project explorer)


So as to do migrations

https://www.nuget.org/packages/dotnet-ef
at command line
a global tool
dotnet tool install --global dotnet-ef --version 5.0.11


Added the connection string in appsettings.developement.json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",                   <<<<< change to Information so we get sql with ef
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Data source=store.db"
  }
}

Ran this in terminal within project API folder
R:\Code\Udemy\Neil\ReactEcommerce\ReStore\API> dotnet tool install --global dotnet-ef --version 5.0.11
says its already installed - Yah


update tools
PS R:\Code\Udemy\Neil\ReactEcommerce\ReStore\API> dotnet tool update --global dotnet-ef --version 5.0.11

list tools
PS R:\Code\Udemy\Neil\ReactEcommerce\ReStore\API> dotnet tool list -g

run
dotnet ef 
to see list of options

Usage: dotnet ef [options] [command]


Options:
  --version        Show version information
  -h|--help        Show help information
  -v|--verbose     Show verbose output.
  --no-color       Don't colorize output.
  --prefix-output  Prefix output with level.


Commands:
  database    Commands to manage the database.
  dbcontext   Commands to manage DbContext types.
  migrations  Commands to manage migrations.


create migration
dotnet ef migrations add InitialCreate -o Data/Migrations    <--- first off indicae where these are


how to apply latest code changes ef
	dotnet ef database update
	
	
 dotnet ef database drop	
 
 Source control Dotnet new -l list all dotnet templates there is  a .gitignore
 dotnet new gitignore
 
 
 React Client first build
 ========================
 material ui v5    import from "@mui/material" not "@material-ui/core"
 
 
 R:\Code\Udemy\Neil\ReactEcommerce\ReStore>npx create-react-app client --template typescript --use-npm
 
 the use npm ensures that even if theres another package manager is installed we use npm, also
 using typescript
 
 hook useEffect used to add a side effect during app lifecycle. 
 It takes 2 params a) callback and b) optional 2nd param
 
 Cors API on port 5001 client on 3000 seen as diff domains
 config the API so it accepts requests from the 3000 and populate the response with correct 
 origin info data as part of the header
 
 update the startup services and configure methods. The order in configuration important 
 need to add cors settings after routing
 
 Client should see response header access control allow origin http://localhost:3000
 
 
 use json2ts - go to swagger endpoint browser on json output and copy into that site to convert to typescript
 then populate Product.tsx file
 
 
 typescript type of [] is a never array
 
 
 project organisation - by feature
 
 Fragments - avoids top level div in component
 see Catalog 
 long way is
     import {Fragment} from "react";
            <Fragment> .... </Fragment>
 shorthand
    no import and write <> </>     
    
 Simplify avoid using props. we destructure
    from props: Props
    to {products, addProduct} : Props
    
    where Props defined as 
    interface Props {
        products: Product[];
        addProduct: () => void;
    }   
    
 Styling   
 old version doesn't play well with react in strict mode
 material ui    
    https://material-ui.com/     
    npm install @material-ui/core
 new version    
    mui.com     (https://mui.com/getting-started/installation/)   
    npm install @mui/material @emotion/react @emotion/styled
    
    add font
    add svg material icons
    
    customisation theme typography https://mui.com/customization/typography/
    
Reset browser styles Add to app.tsx <CssBaseline/>    
Added material UI card based on media one https://mui.com/components/cards/   
The sx prop in material ui shortcut for defining custom styles https://mui.com/system/the-sx-prop/
this is used to add normal css styles e.g. see ProductCard

material UI theme > theming  https://mui.com/customization/theming/
toggle button see app.tsx and header.tsx


React Router
============

Without router simple option return page based on series of if statements
Same page but swaps the components
React Router - web version  npm install react-router-dom
install type definitions
npm install react-router-dom @types/react-router-dom
www.reactrouter.com/web/api
<BrowserRouter> in index

in app
        <Route exact path='/' component={HomePage}/>
        <Route exact path='/catalog' component={Catalog}/>
        <Route path='/catalog/:id' component={ProductDetails}/>
        <Route path='/about' component={AboutPage}/>
        <Route path='/contact' component={ContactPage}/>

http://localhost:3000                     <-- home page
http://localhost:3000/catalog             
http://localhost:3000/about

need 'exact' as the default way path matching happens is '/' matches home and everything else
so we get both homepage and any other components. With exact only '/' matches

header.tsx use react-router 
NavLink - applies an active class - we use this on header
Link - no active class - we use this ProductCard Button 

Passing parameters in the path (see Product Card) 
component={Link} to={`/catalog/${product.id}` 
<Button component={Link} to={`/catalog/${product.id}`} size="small">View</Button> 

links to ProductsDetails, access the param from there
hook - useParams
const {id} = useParams<{id: string}>();

our backend api /localhost:5000/api/products/2 
 

Axios - replace Fetch
---------------------

npm install axios (it comes with type definitions included)
Http client intercept request on way out and response on way back

Material UI 
see themes here https://mui.com/customization/default-theme/  (expand all)
sx styling hover 
'&:hover':{color:'secondary.main'} or better color
'&:hover':{color:'grey.500'},
see Header.tsx
select a class for active link 
'&.active':{color: 'text.secondary'}


Error Handling
==============

Http Responses
200 range     OK
300           Redirection
400           Client error
500           Server Error  
both client and server side

buggyController used to test errors 
swagger
https://localhost:5001/swagger/index.html

replace stand developer exception page with our own
https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0
ordering of middleware is crucial - passed down the tree and back up again see diag at Middleware order

define own exception handling so as to standardise the reponse title, status, detail that show the exception

Client side centralise use of axios

we use the about page to test errors

In axios use error.response instead of error to get back more info (see ProductDetails)

axios interceptor  (see agent.tsx)
  - onFullfilled - any response in 200 range
  - onRejected - anything else (400 or 500)
  always return the error from the interceptor as we cannot catch it in the interceptor so it 
  allows us to see the errors but we must pass it back out of the interceptor so errors can be
  caught in their respective components
  
  see catch in about page
     <Button variant='contained' onClick={()=>agent.TestErrors.get404Error()
        .catch(error => console.log(error))}>Test 404 Error</Button>

    note as error response was sent from interceptor in product details catch error instead
    of error.response
    

Add react toastify    npm install react-toastify
Note wrap components in App.tsx
add switch statement in agent.tsx
Typescript note - use of ! after response overrides type safety for destructuring
response
        const {data,status} = error.response!;
        
Validation errors in client -pull out array of errors (as populated by the modelState on the server)

Handling and Rerouting server errors
------------------------------------- 
Handling server errors - (as raised by About page server error button) we want to route the 
handling from AboutPage to ServerError.tsx
we use react router for this
AboutPage is not part of react  
its inside a route (as seen in react dev tools), it has access to history props and we can 
call push on that this will push a new object onto history state and cause react to load
We need to redirect user from agent.tsx but need access to the route
Looking at 
reactrouter.com  https://reactrouter.com/web/api/Router
currently using BrowserRouter that has access to history object but there is a lower level
router Router which can use to create a history object and reuse this elsewhere
Add history route url to app.tsx and use it in agents.tsx
history.push('/server-error')
Look at React dev tools find ServerError in the object tree and the props available are 
history location match, location has a state and a pathname we can use 
Update agent.tsx with 
case 500:
            // redirect 
            //history.push('/server-error')
            history.push({
                pathname:'/server-error',
                state:{error: data}
            })
            
look again at the react dev tools to see location> state>  error has detail, status and title
all this comes from our ExceptionMiddleware.cs we defined on the server i.e.:
    var response = new ProblemDetails
                    {
                        Status = 500,
                        Detail = _env.IsDevelopment() ? ex.StackTrace?.ToString() : null,
                        Title = ex.Message
                    };
    
In ServerError.tsx we can make use of the above history and location info on the route using hooks
    const history = useHistory();
    // location hook that react provides 
    const {state} = useLocation<any>();

from import {useHistory, useLocation} from "react-router-dom";

our exception is 
at API.Controllers.BuggyController.GetServerError() in R:\Code\Udemy\Neil\ReactEcommerce\ReStore\API\Controllers\BuggyController.cs:line 40
+ other detail of stack trace

Not found Error
---------------
Check this by clicking on a link that goes no where e.g. Login
Added separate NotFound tsx file
and added default route <Route component={NotFound}/>
Switch in react router - 'not found' default fall through if no other route matches
by adding switch we prevent this and make every route exclusive,
avoids Not found being displayed everytime

Also same behaviour for product Not found e.g. /catalog/222
if(!product) return <NotFound/>
added to product details

Simulate a delay when working with API
---------------------------------------
Use material UI added async code to  agent.tsx with js promise and also to axios async await

// simulate a delay, js async using a promise
const sleep =() => new Promise(resolve => setTimeout(resolve, 500));

axios.interceptors.response.use(async response => {
    await sleep();
    return response;
}, 

In Catalog and product Details we use a loading flag that is initially set to true
and a finally block within the useEffect to turn off loading flag

const [loading, setLoading] = useState(true);
useEffect(() => {
        // we have centralised axios withinapp api agent
        agent.Catalog.list()
            .then(products => setProducts(products))
            .catch(error => console.log(error))
            .finally(() => setLoading(false))
    }, []) 
    
// show loading
if(loading) return <LoadingComponent message='loading products...'/>    

loadingComponent uses material UI to draw a spinner


Debug dotnet attach to process API.exe set breakpoint. Avoids stopping app and running in debug mode
Rider Run>Attach to process
Debug React App
Debug in chrome  type this in our code     debugger;  In chrome stop on this line e.g ProductDetails line 12
In Rider 
Application must be running so in terminal npm start
Then we can attach debugger opens another version in chrome
edit config add Javascript Debug, name it react add url http://localhost:3000
select config from drop down list and press Debug
Add breakpoints in client code in Rider as normal
However console logs are better


Shopping Cart
=============

EF relationships, shaping data React context
Store basket on the server (track events in the basket if we want to - not doing that here)
Basket--Items One to many
BaskItem --- Product one to one 
React Context - 
currently with props passing state to children but context doesn't restrain us to parent child.

EF navigation props in entity classes

update StoreContext add DbSet
Did not add BasketItem as we are not going to use that directly only via Basket

dotnet ef migrations add BasketEntityAdded

Issues with migration as its possible to delete a basket and not have that deletion
cascade to basketItems as onDelete: ReferentialAction.Restrict. We need cascade

BasketItem Table
                table.ForeignKey(
                        name: "FK_BasketItem_Baskets_BasketId",
                        column: x => x.BasketId,
                        principalTable: "Baskets",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                        
        Also BasketId can be null
        BasketId = table.Column<int>(type: "INTEGER", nullable: true)
        
        Name is BasketItem we want to pluralize
        
remove migrations

    dotnet ef migrations remove

we can specify convention based annotations to overcome these issues
Fully define relationships on both ends of relationships
eg our basket has List of BasketItems and BasketItems defines BasketId and Basket properties
so both Basket and BasketItem need navigation property - will tell ef we want to cascade deletes

    dotnet ef migrations add BasketEntityAdded

Now in migration BasketItems
    BasketId = table.Column<int>(type: "INTEGER", nullable: false)
    
    table.ForeignKey(
            name: "FK_BasketItems_Baskets_BasketId",
            column: x => x.BasketId,
            principalTable: "Baskets",
            principalColumn: "Id",
            onDelete: ReferentialAction.Cascade); <---------- This is good
            
To Apply migration just start app

BasketController
var basket = await _context.Baskets
                .Include(i=>i.Items)   <---- Basket has basketItems
                .ThenInclude(p=>p.Product) <--- as BasketItems have Products
                .FirstOrDefaultAsync(b => b.BuyerId == Request.Cookies["buyerId"]);
                
Add to Basket 


Cookie
------
we also create a cookie - mark it essential so users refusing cookies know the site won't work
Also don't mark it http only as that excludes it being used in js
Also add cors header so as to receive cookie in client
add AllowCredentials() to useCors in startup
Also in client need withCredentials see changes to agent.tsx
    axios.defaults.withCredentials = true;

In BasketController CreateBasket
var cookieOptions = new CookieOptions
            {
                IsEssential = true,
                Expires = DateTime.Now.AddDays(30),
            };
            // add cookie to response
            Response.Cookies.Append("buyerId", buyerId, cookieOptions);

Adding Items
------------
Use Debugger to walk through the AddItemToBasket method 
use https://localhost:5001/swagger/index.html to run methods
not our ids for basket and basketItem are only populated once we save data into the db.
The cookie is added - check this under the Application tab in chrome and see it holds buyerId
Confirmed in db that records have been created

Currently after adding the item to the basket if we try to call a get request we get a server error
500 possible object cycle was detected - thrown by Json Serializer because
in basket > basketItem (but this also has a navigational ref to basket which in turn have baskItems etc)
Solution is to shape the data. Use DTOs

Add DTOs and tested in swagger using Id 2 and quantity 1 post then Get, 
then repeat post to add more quantity to same Id

CreatedAtRoute
--------------
Post, CreatedAtRoute() method
return CreatedAtRoute("GetBasket",MapBasketToDto(basket) ); // route name, will add location to header   
"GetBasket" is the route that used to get the location url
we need to send back new object or its location in addition to 201
 
location: https://localhost:5001/api/Basket <-- as we have the item in the basket

Client - 
------
update ProductCard 

<LoadingButton 
            loading={loading} 
            onClick={()=>handleAddItem(product.id)} 
            size="small">Add to cart</LoadingButton>
            
            
function handleAddItem(productId:number){ // quantity has a default value of 1 and is optional
      setLoading(true);
      console.log("adding item.... ",productId);
      agent.Basket.addItem(productId) 
          .catch(error => console.log(error))
          .finally(()=>setLoading(false));
  }
  
  
Couldn't get the cookie to work and changed the url to non https and commented out //app.UseHttpsRedirection();
base url is now http://localhost:5000/api/
Everything works
              
clicking the Add to cart produces a cookie now or reuses the existing one.  

Display Basket
--------------
This is what we get from backend get basket
http://localhost:5000/swagger/index.html
{
  "id": 19,
  "buyerId": "1ddb9af2-cf37-4151-93e1-53d4b23ff660",
  "items": [
    {
      "productId": 1,
      "name": "Angular Speedster Board 2000",
      "price": 20000,
      "pictureUrl": "/images/products/sb-ang1.png",
      "brand": "Angular",
      "type": "Boards",
      "quantity": 1
    }
  ]
}        

json2ts.com create interface paste above in generates

 declare module namespace {
 
     export interface Item {
         productId: number;
         name: string;
         price: number;
         pictureUrl: string;
         brand: string;
         type: string;
         quantity: number;
     }
 
     export interface RootObject {
         id: number;
         buyerId: string;
         items: Item[];
     }
 
 }
 
 create basket.tsx on client  
 style basket page https://mui.com/components/tables/#main-content
 
 ReactContext
 ------------
 updating basket item count in header basket icon in StoreContext.tsx
 Added a custom hook useStoreContext
    // custom react hook to work with storeContext
    export function useStoreContext() {
        const context = useContext(StoreContext);
        
        if(context == undefined){
            throw Error('oops we do not seem to be inside the provider');
        }
        
        return context;
    }

 Added store provider to make it easier to work with the basket
 Store context returns 
    <StoreContext.Provider value={{basket, setBasket, removeItem}}>
        {children}
    </StoreContext.Provider>
                               
 We use it by wrapping our elements in App   
 
 Use StoreProvide in Index.tsx highest level                                 
 wrap the app
    <StoreProvider>
        <App />
    </StoreProvider>
    
 Use our StoreContext fetching the basket on app start
 Check in the client - have we got a basket? if we have a cookie with basketId then there
 should be a basket on the server.   
 
 Added util regex find cookie via the window document
 
 Check in chrom dev tools when loading react components that StoreProvider is in the hierachy
 Go to home page and check if we have the basket contents
 
 
 Updated header with basket item count.
 The basket data now comes from the StoreContext so in basket page we don't need to 
 fetch it each time if theres a cookie. Update the basket item count and wire up the 
 ProductCard add item to update the basket, as up to this point we have just made
 a post request to update the basket on the server not the client so we only get 
 an updated basket upon browser refresh.
 
 Check empty basket - turn off loading (test this in incognito window in browser)
 in App.tsx
 
 Implemented Add Remove Delete buttons and operations
 
 // remember ?? trick to handle undefined values as left most argument will be 0
 const subtotal = basket?.items.reduce((sum, item)=> sum + (item.price * item.quantity),0) ?? 0; <-- if undefined then right arg
 
 Update product detail section to add / remove item in the basket
 
 Update product detail
 UseEffect watch out for dependencies - look in console for issues e.g.
  Line 32:7:   React Hook useEffect has a missing dependency: 'item'. Either include it or remove the dependency array  react-hooks/exhaustive-deps
  useEffect(() => {
          if(item) setQuantity(item.quantity);
          ....
          
           },[id]) // dependency so far is id
           
           change to
           },[id, item]) 
           
           
  TextField is just an html element and react knows nothing about it (as an Uncontrolled component) as it cannot see the changes so we
  need to turn it into a controlled component  
  
  product?.id! <-- exclamation overrides typescript type safety re possible undefined
  
  add logic to prevent updating cart if we have made no quantity changes and prevent adding to cart where quantity is 0
  <LoadingButton disabled={item?.quantity === quantity || !item && quantity === 0 } 
  
  ... last commit fba78d3
  
  
  Redux and React-Redux
  ---------------------
  redux.js.org/style-guide
  Redux Toolkit and Redux Dev tools
  React-Redux provider
  
  starting and ending with components flow is one way:
  
  Components -> Actions ->  Reducers  ->  *** Store *** -> Provider -> App  -> Components
  
  example reducers - one for catalog, one for basket
  a reducer is a function, it takes the current state and an action and returns a new state result
  (state, action) => newState
  
  best practices
  * can't mutate state
  * reducers must be side effect free so pure functions
  * do not have non serializable values in state or actions (so not class instances or functions inside state)
  * 1 store per app
  
  Redux Toolkit simplifies working with redux and its opinionated. 
  Good defaults and redux add-on. Less boiler plate
  
  npm install redux react-redux
  
  Use the aboutPage.tsx as a playground to explore redux
  
  actions are dispatched to reducers to change the store state
  
  example of reducer and provider
  
  define configureStore that accepts our reducer 
      export function configureStore() {
          return createStore(counterReducer); // createStore part of redux
      }
  
  counterReducer defined as 
  
      // basic example
      export interface CounterState {
          data : number;
          title: string;
      }
      
      const initialState:CounterState = {
          data: 42,
          title: 'foo'
      }
      
      // actions are dispatched to reducers to change their state
      export default function counterReducer(state = initialState, action: any){
          return state;
      }
  ---
  
  Usage:
  in index.tsx 
  const store = configureStore();
  
  // provide rect with access
                <Provider store={store}>
                    <App />
                </Provider>
                

  
  console.log(store.getState());
  
  in contactPage.tsx
  destructure data and title from state of type CounterState
  const {data, title} = useSelector((state: CounterState) => state)
  
  Actions
  -------
  in counterReducer define types as
  export const INCREMENT_COUNTER = "INCREMENT_COUNTER";
  export const DECREMENT_COUNTER = "DECREMENT_COUNTER";
  
  these are then dispatched to the reducer and using a switch statement new state is created
  (as we are not allowed to mutate state) and the respective properties are updated on the new copy
  as seen in the switch statement below
  
  export default function counterReducer(state = initialState, action: any){
      switch (action.type) {
          case INCREMENT_COUNTER:
              return {
                  // cannot mutate state e.g. state.data + 1 
                  // instead create a new copy
                  // use spread operator to copy the override data with new value
                  ...state,
                  data: state.data + 1
              }
              break;
          case DECREMENT_COUNTER:
              return {
                  ...state,
                  data: state.data - 1
              }
              break;
          default:
              return state; // always return state
      }
      
      
How are the actions dispatched? 
there is a dispatcher that react-redux provides see ContactPage
      
      const dispatch = useDispatch();
      
      
      then we drive the action from buttons + or -
      dispatch(pass in action type)
      
      <Button onClick={()=>dispatch({type: DECREMENT_COUNTER })}  variant='contained' color='error'>Decrement</Button>
      <Button onClick={()=>dispatch({type: INCREMENT_COUNTER })} variant='contained' color='primary'>Increment</Button>
      
Action creators 
used in reducer or in separate files, these are functions that return the action types     
they can be used to pass a payload so we can + or subtract by diff amounts

functions in the reducer are defined as 
    export function increment(amount = 1) {
        return {
            type: INCREMENT_COUNTER,
            payload: amount // if change by something other than 1
        }
    }
    
    export function decrement(amount = 1) {
        return {
            type: DECREMENT_COUNTER,
            payload: amount // if change by something other than 1
        }
    } 
    
Then the reducer changes to use action payload instead of 1
    export default function counterReducer(state = initialState, action: any){
        switch (action.type) { <------------ action type 
            case INCREMENT_COUNTER:
                return {
                    ...state,
                    data: state.data + action.payload   <--------------action payload
                }
                break;
            case DECREMENT_COUNTER:
                return {
                    ...state,
                    data: state.data - action.payload
                }
                break;
            default:
                return state; // always return state
        }
    
    
Then in contact page we call the functions instead
    
    use default payload of 1
    
    <Button onClick={()=>dispatch(decrement())}  variant='contained' color='error'>Decrement</Button>
    <Button onClick={()=>dispatch(increment())} variant='contained' color='primary'>Increment</Button>
    
    pass in payload other than default
    
    <Button onClick={()=>dispatch(increment(6))} variant='contained' color='secondary'>Increment by 6</Button>
    

Redux Toolkit 
-------------
does away with a lot of the boiler plate helps with following best practices

npm install @reduxjs/toolkit

simplifies things as now reducer called counterSlice is 
    import { createSlice } from "@reduxjs/toolkit"
    
    
    export interface CounterState {
        data : number;
        title: string;
    }
    
    const initialState:CounterState = {
        data: 42,
        title: 'redux counter example with the redux toolkit'
    }
    
    // action types and action creators are created for us 
    export const counterSlice = createSlice({
        name: 'counter',
        initialState,
        reducers: {
            increment: (state, action) => {
                // What? we are mutating state but inner workings of toolkit
                // use immer where immuatble states are created from mutable ones
                // so its ok
                state.data += action.payload;
            },
            decrement: (state, action) => {
                state.data -= action.payload;
            }
        }
    })
    
    export const  { increment, decrement } = counterSlice.actions;
    
configure store along with convenience custom hooks

    import { configureStore } from "@reduxjs/toolkit";
    import { TypedUseSelectorHook, useDispatch, useSelector } from "react-redux";
    import { counterSlice } from "../../features/contact/counterSlice";
    
    export const store = configureStore({
        reducer: {
            counter: counterSlice.reducer
        }
    })
    
    // for ease of use
    // avoids in contact page having to specify CounterState
    export type RootState = ReturnType<typeof store.getState>;
    export type AppDispatch = typeof store.dispatch;
    
    // custom hooks
    export const useAppDispatch = () => useDispatch<AppDispatch>(); // typed to store dispatch
    export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector; // store state
    
All we need in the index.tsx is 

import { store } from './app/store/configureStore';
    <StoreProvider>
        <Provider store={store}>
              <App />
        </Provider>
    </StoreProvider>    
    
    
and contact page becomes
    import { useAppDispatch, useAppSelector } from "../../app/store/configureStore";
    import { decrement, increment } from "./counterSlice";

    const dispatch = useAppDispatch();
    const {data, title} = useAppSelector(state => state.counter); 
    
    <Button onClick={()=>dispatch(decrement(1))}  variant='contained' color='error'>Decrement</Button>
    <Button onClick={()=>dispatch(increment(1))} variant='contained' color='primary'>Increment</Button>    
    
which is all a little bit simpler    
    
    
Implement the basketSlice and add it to the configureStore    
in app stop using useStoreContext 
replace 
    use const {setBasket} = useStoreContext();
with 
    const dispatch = useAppDispatch();
    
and in the agent call to get the basket use the dispatcher to get the basket
    agent.Basket.get()
                    .then(basket => dispatch(setBasket(basket)))           

Async
-----
Redux way - redux-thunk returns a fn from a fn
But instead use redux toolkit CreateAsyncThunk

centralise code where we get the basket from the agent
see basketSlice where we make use of createAsyncThunk

extraReducers using the builder package are added to the project to set state and actions

Usage:...
In productCard remove handleAddItem and make use of useAppSelector to set a status 
property based on basket status. Updated LoadingButton on product card.

in redux tools in browser you can see the payload that shows all basket items when a product is added 

Entity Adapters
---------------
Aim is to store data in a catalogSlice 
Prevent products loading each time
Entity Adapters - Redux Toolkit managing normalised data organise data in state as ids as keys and entity
as values createEntityAdapter - see catalogSlice

Add catalog slice to configureStore list of reducers
Looking at app in chrome with redux tools on the catalog page the @@init state is 

catalog
    ids: []    *
    entities: {}   * 
    productsLoaded:false
    status:"idle"
    
* given to use by productsAdapter    

temporarily we get products from store dispatch see index page

looking at chrome again we can see fetchProductsAsync pending and fulfilled
and the state shows our entities loaded and an array of ids

work with selectors to work with products use these in Catalog we can remove our local state
and ensure products are loaded once

Do the same for productDetails load once.

Errors now that we are using async thunks, currently trying to access a non 
existent productId crashes the app. In production mode the loading screen will permanently display
(so no error message is visible to end user).
Fixing the issues - catalogSlice
AsyncThunks are outer functions that contain an inner function, we catch errors in inner but not the outer.
Added error handling using thunkAPI
Fixed productDetails to get loading working when updating quantity

Working on basket error handling


Pagination sorting filtering
----------------------------

parameters passed in query string
localhost:5000/api/products?pageNumber=1&pageSize=5
defer execution of an expression using an expression tree IQueryable<T>
orderBy where take skip

sorting 
pass in an orderBy parameter to ProductsController GetProducts
GET "http://localhost:5000/api/Products - order by name
GET "http://localhost:5000/api/Products?orderBy=price"      - price low to high
GET "http://localhost:5000/api/Products?orderBy=priceDesc"  - price high to low

we could organise code in DbContext (that's a combination of unit of work and repository)
we use extension methods ProductsExtension to extend queryable

searching
same idea GET "http://localhost:5000/api/Products?searchTerm=red"
GET "http://localhost:5000/api/Products?orderBy=price&searchTerm=blue"

filtering
GET "http://localhost:5000/api/Products?types=hats"
GET "http://localhost:5000/api/Products?brands=react&types=hats"
GET "http://localhost:5000/api/Products?brands=redis&types=hats" // nothing back  

query both hats or boots  hats,boots
GET "http://localhost:5000/api/Products?types=hats%2Cboots"

pagination
pageNumber and size of page
added Request helpers and grouped all product params in a class
created a MetaData class to return to client with page details
Return a PageList rather than a list
Extend List<Page>
[FromQuery] is needed as we are passing in to the action method an object and without this
Swagger assumes that the object will be passed in the body as a json object which is not we we want

http://localhost:5000/api/Products
Response header: 
        content-type: application/json; charset=utf-8 
        date: Tue30 Nov 2021 16:51:53 GMT 
        pagination: {"CurrentPage":1,"TotalPages":3,"PageSize":6,"TotalCount":18} 
        
        3 pages as we have 18 products

default page size is 6
GET "http://localhost:5000/api/Products?pageNumber=2" <------select page 2
Response header: 
        content-type: application/json; charset=utf-8 
        date: Tue30 Nov 2021 16:53:36 GMT 
        pagination: {"CurrentPage":2,"TotalPages":3,"PageSize":6,"TotalCount":18} 

GET "http://localhost:5000/api/Products?pageNumber=2&PageSize=4"      <----- page 2 with page size of 4  
Response header: 
        content-type: application/json; charset=utf-8 
         date: Tue30 Nov 2021 16:54:36 GMT 
         pagination: {"CurrentPage":2,"TotalPages":5,"PageSize":4,"TotalCount":18} 
        
GET "http://localhost:5000/api/Products?Brands=redis" <--- should only be 1 result
        content-type: application/json; charset=utf-8 
         date: Tue30 Nov 2021 16:56:54 GMT 
         pagination: {"CurrentPage":1,"TotalPages":1,"PageSize":6,"TotalCount":1}        
        
        
Need JSON in camelCase currently its in title case
Also CORs custom response header             
   Response header:
        access-control-expose-headers: Pagination  <------------------- Cors
         content-type: application/json; charset=utf-8 
         date: Tue30 Nov 2021 17:12:11 GMT 
         pagination: {"currentPage":1,"totalPages":3,"pageSize":6,"totalCount":18} <----- camelCase
         

Return list types and brands added getFilters to products Controller   

Client 

Getting filter lists from API and storing in redux
Update client to handle fetchFilters  update agent, catalogSlice and Catalog    
check redux tools to make sure we are not duplicating calls (added another useEffect to Catalog page to avoid this) 
and check network tab check headers
Pagination: {"currentPage":1,"totalPages":3,"pageSize":6,"totalCount":18}
Access-Control-Expense-Headers:Pagination     ----cors


sending product params up to api - create state inside redux store
axios get request to work with params

In the Agent client making request to get products needs to send up the query string with search sort filtering paging etc
currently we have Catalog list: ()=>requests.get('products') and want to avoid adding each param manually:
1) add params to get request
    get: (url:string, params?:URLSearchParams) => axios.get(url, {params}).then(responseBody),
2) use the params in Catalog get request
    list: (params: URLSearchParams)=>requests.get('products', params),

URLSearchParams is a utility method available to us when working with the web https://developer.mozilla.org/en-US/docs/Web/API
Update CatalogSlice to work with params
Check in chrome network tools http://localhost:5000/api/products?pageNumber=1&pageSize=6&orderBy=name

Search
added new component TextField on change to set the productParams with searchTerm which are store in the state
when this event fires we dispatch to catalogSlice and call setProductParams where state productsLoaded = false
and state.productParams we pass  action.payload that has the searchTerm which will overwrite that 
part of state.productParams with searchTerm. As productsLoaded changes as its a dependency of useEffect
then useEffect runs again this will fetch productsAsync this will make a request to our api which now includes
search.
Add debounce function to slow down responsiveness of search box 

Sorting 
with radio buttons in catalog
Add more generic component > RadioButtonGroup
add this to Catalog
Check the network tab in chrome orderyBy name, price, priceDesc e.g.
http://localhost:5000/api/products?pageNumber=1&pageSize=6&orderBy=priceDesc