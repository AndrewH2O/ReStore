React Ecommerce Neil Cummings Working with Rider

github.com/tryCatchLearn/restore

https://www.udemy.com/course/learn-to-build-an-e-commerce-store-with-dotnet-react-redux/learn/lecture/28964744#overview

API Server first build
======================

dotnet cli

Whats a web API : Http based services on top of .net

client http request and server sends http response
stateless
cacheable 
uniform interface

/Products     	GET      get all products
/Products/3		GET		 get product with id 3
/Products		POST     create new product
/Products/3		PUT		 update product with ID 3
/Products/3		DELETE	 delete product with ID 3 


dotnet new -l    // list all project types


create solution file and then and webapi


our solution is called ReStore

	dotnet new sln // creates solution

	dotnet new webapu -o API    // output folder


add project to solution
	dotnet sln add API



dotnet watch run  // means don't need to  restart - how to do this in Rider


EF
--

modelling
querying
change tracking
saving
concurrency
transactions
caching
conventions
configurations
migrations

add EF using nuget
<PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="5.0.11">
<PackageReference Include="Microsoft.EntityFrameworkCore.Sqlite" Version="5.0.11" />



see API.csproj (show this file by selecting 'File System' in project explorer)


So as to do migrations

https://www.nuget.org/packages/dotnet-ef
at command line
a global tool
dotnet tool install --global dotnet-ef --version 5.0.11


Added the connection string in appsettings.developement.json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",                   <<<<< change to Information so we get sql with ef
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Data source=store.db"
  }
}

Ran this in terminal within project API folder
R:\Code\Udemy\Neil\ReactEcommerce\ReStore\API> dotnet tool install --global dotnet-ef --version 5.0.11
says its already installed - Yah


update tools
PS R:\Code\Udemy\Neil\ReactEcommerce\ReStore\API> dotnet tool update --global dotnet-ef --version 5.0.11

list tools
PS R:\Code\Udemy\Neil\ReactEcommerce\ReStore\API> dotnet tool list -g

run
dotnet ef 
to see list of options

Usage: dotnet ef [options] [command]


Options:
  --version        Show version information
  -h|--help        Show help information
  -v|--verbose     Show verbose output.
  --no-color       Don't colorize output.
  --prefix-output  Prefix output with level.


Commands:
  database    Commands to manage the database.
  dbcontext   Commands to manage DbContext types.
  migrations  Commands to manage migrations.


create migration
dotnet ef migrations add InitialCreate -o Data/Migrations    <--- first off indicae where these are


how to apply latest code changes ef
	dotnet ef database update
	
	
 dotnet ef database drop	
 
 Source control Dotnet new -l list all dotnet templates there is  a .gitignore
 dotnet new gitignore
 
 
 React Client first build
 ========================
 material ui v5    import from "@mui/material" not "@material-ui/core"
 
 
 R:\Code\Udemy\Neil\ReactEcommerce\ReStore>npx create-react-app client --template typescript --use-npm
 
 the use npm ensures that even if theres another package manager is installed we use npm, also
 using typescript
 
 hook useEffect used to add a side effect during app lifecycle. 
 It takes 2 params a) callback and b) optional 2nd param
 
 Cors API on port 5001 client on 3000 seen as diff domains
 config the API so it accepts requests from the 3000 and populate the response with correct 
 origin info data as part of the header
 
 update the startup services and configure methods. The order in configuration important 
 need to add cors settings after routing
 
 Client should see response header access control allow origin http://localhost:3000
 
 
 use json2ts - go to swagger endpoint browser on json output and copy into that site to convert to typescript
 then populate Product.tsx file
 
 
 typescript type of [] is a never array
 
 
 project organisation - by feature
 
 Fragments - avoids top level div in component
 see Catalog 
 long way is
     import {Fragment} from "react";
            <Fragment> .... </Fragment>
 shorthand
    no import and write <> </>     
    
 Simplify avoid using props. we destructure
    from props: Props
    to {products, addProduct} : Props
    
    where Props defined as 
    interface Props {
        products: Product[];
        addProduct: () => void;
    }   
    
 Styling   
 old version doesn't play well with react in strict mode
 material ui    
    https://material-ui.com/     
    npm install @material-ui/core
 new version    
    mui.com     (https://mui.com/getting-started/installation/)   
    npm install @mui/material @emotion/react @emotion/styled
    
    add font
    add svg material icons
    
    customisation theme typography https://mui.com/customization/typography/
    
Reset browser styles Add to app.tsx <CssBaseline/>    
Added material UI card based on media one https://mui.com/components/cards/   
The sx prop in material ui shortcut for defining custom styles https://mui.com/system/the-sx-prop/
this is used to add normal css styles e.g. see ProductCard

material UI theme > theming  https://mui.com/customization/theming/
toggle button see app.tsx and header.tsx


React Router
============

Without router simple option return page based on series of if statements
Same page but swaps the components
React Router - web version  npm install react-router-dom
install type definitions
npm install react-router-dom @types/react-router-dom
www.reactrouter.com/web/api
<BrowserRouter> in index

in app
        <Route exact path='/' component={HomePage}/>
        <Route exact path='/catalog' component={Catalog}/>
        <Route path='/catalog/:id' component={ProductDetails}/>
        <Route path='/about' component={AboutPage}/>
        <Route path='/contact' component={ContactPage}/>

http://localhost:3000                     <-- home page
http://localhost:3000/catalog             
http://localhost:3000/about

need 'exact' as the default way path matching happens is '/' matches home and everything else
so we get both homepage and any other components. With exact only '/' matches

header.tsx use react-router 
NavLink - applies an active class - we use this on header
Link - no active class - we use this ProductCard Button 

Passing parameters in the path (see Product Card) 
component={Link} to={`/catalog/${product.id}` 
<Button component={Link} to={`/catalog/${product.id}`} size="small">View</Button> 

links to ProductsDetails, access the param from there
hook - useParams
const {id} = useParams<{id: string}>();

our backend api /localhost:5000/api/products/2 
 

Axios - replace Fetch
---------------------

npm install axios (it comes with type definitions included)
Http client intercept request on way out and response on way back

Material UI 
see themes here https://mui.com/customization/default-theme/  (expand all)
sx styling hover 
'&:hover':{color:'secondary.main'} or better color
'&:hover':{color:'grey.500'},
see Header.tsx
select a class for active link 
'&.active':{color: 'text.secondary'}


Error Handling
==============

Http Responses
200 range     OK
300           Redirection
400           Client error
500           Server Error  
both client and server side

buggyController used to test errors 
swagger
https://localhost:5001/swagger/index.html

replace stand developer exception page with our own
https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0
ordering of middleware is crucial - passed down the tree and back up again see diag at Middleware order

define own exception handling so as to standardise the reponse title, status, detail that show the exception

Client side centralise use of axios

we use the about page to test errors

In axios use error.response instead of error to get back more info (see ProductDetails)

axios interceptor  (see agent.tsx)
  - onFullfilled - any response in 200 range
  - onRejected - anything else (400 or 500)
  always return the error from the interceptor as we cannot catch it in the interceptor so it 
  allows us to see the errors but we must pass it back out of the interceptor so errors can be
  caught in their respective components
  
  see catch in about page
     <Button variant='contained' onClick={()=>agent.TestErrors.get404Error()
        .catch(error => console.log(error))}>Test 404 Error</Button>

    note as error response was sent from interceptor in product details catch error instead
    of error.response
    

Add react toastify    npm install react-toastify
Note wrap components in App.tsx
add switch statement in agent.tsx
Typescript note - use of ! after response overrides type safety for destructuring
response
        const {data,status} = error.response!;
        
Validation errors in client -pull out array of errors (as populated by the modelState on the server)

Handling and Rerouting server errors
------------------------------------- 
Handling server errors - (as raised by About page server error button) we want to route the 
handling from AboutPage to ServerError.tsx
we use react router for this
AboutPage is not part of react  
its inside a route (as seen in react dev tools), it has access to history props and we can 
call push on that this will push a new object onto history state and cause react to load
We need to redirect user from agent.tsx but need access to the route
Looking at 
reactrouter.com  https://reactrouter.com/web/api/Router
currently using BrowserRouter that has access to history object but there is a lower level
router Router which can use to create a history object and reuse this elsewhere
Add history route url to app.tsx and use it in agents.tsx
history.push('/server-error')
Look at React dev tools find ServerError in the object tree and the props available are 
history location match, location has a state and a pathname we can use 
Update agent.tsx with 
case 500:
            // redirect 
            //history.push('/server-error')
            history.push({
                pathname:'/server-error',
                state:{error: data}
            })
            
look again at the react dev tools to see location> state>  error has detail, status and title
all this comes from our ExceptionMiddleware.cs we defined on the server i.e.:
    var response = new ProblemDetails
                    {
                        Status = 500,
                        Detail = _env.IsDevelopment() ? ex.StackTrace?.ToString() : null,
                        Title = ex.Message
                    };
    
In ServerError.tsx we can make use of the above history and location info on the route using hooks
    const history = useHistory();
    // location hook that react provides 
    const {state} = useLocation<any>();

from import {useHistory, useLocation} from "react-router-dom";

our exception is 
at API.Controllers.BuggyController.GetServerError() in R:\Code\Udemy\Neil\ReactEcommerce\ReStore\API\Controllers\BuggyController.cs:line 40
+ other detail of stack trace

Not found Error
---------------
Check this by clicking on a link that goes no where e.g. Login
Added separate NotFound tsx file
and added default route <Route component={NotFound}/>
Switch in react router - 'not found' default fall through if no other route matches
by adding switch we prevent this and make every route exclusive,
avoids Not found being displayed everytime

Also same behaviour for product Not found e.g. /catalog/222
if(!product) return <NotFound/>
added to product details

Simulate a delay when working with API
---------------------------------------
Use material UI added async code to  agent.tsx with js promise and also to axios async await

// simulate a delay, js async using a promise
const sleep =() => new Promise(resolve => setTimeout(resolve, 500));

axios.interceptors.response.use(async response => {
    await sleep();
    return response;
}, 

In Catalog and product Details we use a loading flag that is initially set to true
and a finally block within the useEffect to turn off loading flag

const [loading, setLoading] = useState(true);
useEffect(() => {
        // we have centralised axios withinapp api agent
        agent.Catalog.list()
            .then(products => setProducts(products))
            .catch(error => console.log(error))
            .finally(() => setLoading(false))
    }, []) 
    
// show loading
if(loading) return <LoadingComponent message='loading products...'/>    

loadingComponent uses material UI to draw a spinner


Debug dotnet attach to process API.exe set breakpoint. Avoids stopping app and running in debug mode
Rider Run>Attach to process
Debug React App
Debug in chrome  type this in our code     debugger;  In chrome stop on this line e.g ProductDetails line 12
In Rider 
Application must be running so in terminal npm start
Then we can attach debugger opens another version in chrome
edit config add Javascript Debug, name it react add url http://localhost:3000
select config from drop down list and press Debug
Add breakpoints in client code in Rider as normal
However console logs are better


Shopping Cart
=============

EF relationships, shaping data React context
Store basket on the server (track events in the basket if we want to - not doing that here)
Basket--Items One to many
BaskItem --- Product one to one 
React Context - 
currently with props passing state to children but context doesn't restrain us to parent child.

EF navigation props in entity classes

update StoreContext add DbSet
Did not add BasketItem as we are not going to use that directly only via Basket

dotnet ef migrations add BasketEntityAdded

Issues with migration as its possible to delete a basket and not have that deletion
cascade to basketItems as onDelete: ReferentialAction.Restrict. We need cascade

BasketItem Table
                table.ForeignKey(
                        name: "FK_BasketItem_Baskets_BasketId",
                        column: x => x.BasketId,
                        principalTable: "Baskets",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Restrict);
                        
        Also BasketId can be null
        BasketId = table.Column<int>(type: "INTEGER", nullable: true)
        
        Name is BasketItem we want to pluralize
        
remove migrations

    dotnet ef migrations remove

we can specify convention based annotations to overcome these issues
Fully define relationships on both ends of relationships
eg our basket has List of BasketItems and BasketItems defines BasketId and Basket properties
so both Basket and BasketItem need navigation property - will tell ef we want to cascade deletes

    dotnet ef migrations add BasketEntityAdded

Now in migration BasketItems
    BasketId = table.Column<int>(type: "INTEGER", nullable: false)
    
    table.ForeignKey(
            name: "FK_BasketItems_Baskets_BasketId",
            column: x => x.BasketId,
            principalTable: "Baskets",
            principalColumn: "Id",
            onDelete: ReferentialAction.Cascade); <---------- This is good
            
To Apply migration just start app

BasketController
var basket = await _context.Baskets
                .Include(i=>i.Items)   <---- Basket has basketItems
                .ThenInclude(p=>p.Product) <--- as BasketItems have Products
                .FirstOrDefaultAsync(b => b.BuyerId == Request.Cookies["buyerId"]);
                
Add to Basket 


Cookie
------
we also create a cookie - mark it essential so users refusing cookies know the site won't work
Also don't mark it http only as that excludes it being used in js
Also add cors header so as to receive cookie in client
add AllowCredentials() to useCors in startup
Also in client need withCredentials see changes to agent.tsx
    axios.defaults.withCredentials = true;

In BasketController CreateBasket
var cookieOptions = new CookieOptions
            {
                IsEssential = true,
                Expires = DateTime.Now.AddDays(30),
            };
            // add cookie to response
            Response.Cookies.Append("buyerId", buyerId, cookieOptions);

Adding Items
------------
Use Debugger to walk through the AddItemToBasket method 
use https://localhost:5001/swagger/index.html to run methods
not our ids for basket and basketItem are only populated once we save data into the db.
The cookie is added - check this under the Application tab in chrome and see it holds buyerId
Confirmed in db that records have been created

Currently after adding the item to the basket if we try to call a get request we get a server error
500 possible object cycle was detected - thrown by Json Serializer because
in basket > basketItem (but this also has a navigational ref to basket which in turn have baskItems etc)
Solution is to shape the data. Use DTOs

Add DTOs and tested in swagger using Id 2 and quantity 1 post then Get, 
then repeat post to add more quantity to same Id

CreatedAtRoute
--------------
Post, CreatedAtRoute() method
return CreatedAtRoute("GetBasket",MapBasketToDto(basket) ); // route name, will add location to header   
"GetBasket" is the route that used to get the location url
we need to send back new object or its location in addition to 201
 
location: https://localhost:5001/api/Basket <-- as we have the item in the basket

Client - 
------
update ProductCard 

<LoadingButton 
            loading={loading} 
            onClick={()=>handleAddItem(product.id)} 
            size="small">Add to cart</LoadingButton>
            
            
function handleAddItem(productId:number){ // quantity has a default value of 1 and is optional
      setLoading(true);
      console.log("adding item.... ",productId);
      agent.Basket.addItem(productId) 
          .catch(error => console.log(error))
          .finally(()=>setLoading(false));
  }
  
  
Couldn't get the cookie to work and changed the url to non https and commented out //app.UseHttpsRedirection();
base url is now http://localhost:5000/api/
Everything works
              
clicking the Add to cart produces a cookie now or reuses the existing one.  

Display Basket
--------------
This is what we get from backend get basket
http://localhost:5000/swagger/index.html
{
  "id": 19,
  "buyerId": "1ddb9af2-cf37-4151-93e1-53d4b23ff660",
  "items": [
    {
      "productId": 1,
      "name": "Angular Speedster Board 2000",
      "price": 20000,
      "pictureUrl": "/images/products/sb-ang1.png",
      "brand": "Angular",
      "type": "Boards",
      "quantity": 1
    }
  ]
}        

json2ts.com create interface paste above in generates

 declare module namespace {
 
     export interface Item {
         productId: number;
         name: string;
         price: number;
         pictureUrl: string;
         brand: string;
         type: string;
         quantity: number;
     }
 
     export interface RootObject {
         id: number;
         buyerId: string;
         items: Item[];
     }
 
 }
 
 create basket.tsx on client  
 style basket page https://mui.com/components/tables/#main-content
 
 ReactContext
 ------------
 updating basket item count in header basket icon in StoreContext.tsx
 Added a custom hook useStoreContext
    // custom react hook to work with storeContext
    export function useStoreContext() {
        const context = useContext(StoreContext);
        
        if(context == undefined){
            throw Error('oops we do not seem to be inside the provider');
        }
        
        return context;
    }

 Added store provider to make it easier to work with the basket
 Store context returns 
    <StoreContext.Provider value={{basket, setBasket, removeItem}}>
        {children}
    </StoreContext.Provider>
                               
 We use it by wrapping our elements in App   
 
 Use StoreProvide in Index.tsx highest level                                 
 wrap the app
    <StoreProvider>
        <App />
    </StoreProvider>
    
 Use our StoreContext fetching the basket on app start
 Check in the client - have we got a basket? if we have a cookie with basketId then there
 should be a basket on the server.   
 
 Added util regex find cookie via the window document
 
 Check in chrom dev tools when loading react components that StoreProvider is in the hierachy
 Go to home page and check if we have the basket contents
 
 
 Updated header with basket item count.
 The basket data now comes from the StoreContext so in basket page we don't need to 
 fetch it each time if theres a cookie. Update the basket item count and wire up the 
 ProductCard add item to update the basket, as up to this point we have just made
 a post request to update the basket on the server not the client so we only get 
 an updated basket upon browser refresh.
 
 Check empty basket - turn off loading (test this in incognito window in browser)
 in App.tsx
 
 Implemented Add Remove Delete buttons and operations
 
 // remember ?? trick to handle undefined values as left most argument will be 0
 const subtotal = basket?.items.reduce((sum, item)=> sum + (item.price * item.quantity),0) ?? 0; <-- if undefined then right arg